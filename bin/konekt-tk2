#!/usr/bin/env ruby
# Konekraft/bin/reaktk
# Konekt Toolkit
require 'konekraft/konekt2'
require 'konekraft/cli/common'
require 'yaml'

puts "Konekt Interactive Toolkit"
puts "Konekraft Version #{Konekraft::VERSION}"
puts "Konekraft::Konekt2 Version #{Konekraft::Konekt2::VERSION}"

@networks = []
@prompt_heading = "konekt"

def keyword_new
  "new".magenta
end

def find_network(network_id)
  network = @networks[network_id]
  if network
    yield network if block_given?
  else
    log_error "network[#{network_id}] not found"
  end
  network
end

def find_konekt(network, opts)
  konekt = network.find(opts)
  if konekt
    yield konekt if block_given?
  else
    log_error "[#{network.id_s}] ".light_blue << "konekt[#{opts}] not found"
  end
  konekt
end

def find_konekt_class(konekt_type)
  begin
    konekt_klass = Konekraft::Konekt2.find(konekt_type)
    yield konekt_klass
    return konekt_klass
  rescue KeyError
    log_error "konekt type[#{konekt_type}] not found"
    return nil
  end
end

def process_command(raw_command)
  command = subsitute_env(raw_command)
  case command
  when 'env'
    @env_table.each do |k, v|
      puts "#{k} => #{v}"
    end
  when /\Aunset\s(\S+)/
    @env_table.delete($1)
  when /\Aset\s(\S+)\s(.*)/i
    @env_table[$1] = $2
  when /\Aecho\s*(.*)/
    puts $1
  when 'run'
    t = 0
    d = "..ili".split("")
    idle_anim = d.size.times.map { |i| d.rotate(-i).join }
    begin
      loop do
        @networks.each(&:step)
        sleep 0.25
        t += 1
        print "\rRunning [#{idle_anim[t % idle_anim.size]}] #{t}"
      end
    rescue Interrupt
    end
    puts "\rRan for #{t} ticks                "
  when 'step'
    @networks.each(&:step)
  when 'status'
    @networks.each do |network|
      puts "[#{network.id_s}] ".light_blue << "ticks=#{network.ticks}"
      network.konekts.each do |konekt|
        puts "  #{konekt.id_s} ".light_blue << konekt.export_h.map{|k,v|"#{k}=#{v}"}.join(" ")
      end
    end
  when 'new network'
    network = Konekraft::Konekt2::Network.new
    network.id = @networks.size
    @networks << network
    @env_table["last_network_id"] = network.id.to_s
    puts "#{keyword_new} Network #{network.id_s}"
  when /\Anew konekt\s(\d+)\s(\S+)(\s\+)?/
    network_id   = $1.to_i
    konekt_type = $2
    is_main      = !!$3
    find_network(network_id) do |network|
      find_konekt_class(konekt_type) do |konekt_klass|
        konekt = network.add_from_class(konekt_klass, is_main)
        @env_table["last_konekt_id"] = "#{konekt.id}"
        puts "[#{network.id_s}] ".light_blue << "#{keyword_new} #{is_main ? "main " : ""}Konekt #{konekt.id_s}"
      end
    end
  when /\Aconnect konekt\s(\d+)\s(\d+)\/(\S+)\s([><\|])\s(\d+)\/(\S+)/
    network_id = $1.to_i
    output_konekt_id = $2.to_i
    output_konekt_port_id = $3
    connection_method = $4
    input_konekt_id = $5.to_i
    input_konekt_port_id = $6
    find_network(network_id) do |network|
      okonekt = find_konekt(network, id: output_konekt_id)
      return unless okonekt
      ikonekt = find_konekt(network, id: input_konekt_id)
      return unless ikonekt
      out_port = okonekt/output_konekt_port_id.to_sym
      in_port  = ikonekt/input_konekt_port_id.to_sym
      out_port.send(connection_method, in_port)
      puts "[#{network.id_s}] ".light_blue << "connected #{okonekt.id_s}/#{out_port.name} to #{ikonekt.id_s}/#{in_port.name}"
    end
  when /\Aproperty get\s(\d+)\s(\d+)\s(\S+)/
    network_id   = $1.to_i
    konekt_id   = $2.to_i
    property_key = $3
    find_network(network_id) do |network|
      find_konekt(network, id: konekt_id) do |konekt|
        begin
          puts @env_table["0"] = konekt.property_get(property_key)
        rescue KeyError => ex
          print "[#{network.id_s}][#{konekt.id_s}] ".light_blue
          log_error ex.message
        end
      end
    end
  when /\Aproperty set\s(\d+)\s(\d+)\s(\S+)\s(.*)/
    network_id   = $1.to_i
    konekt_id   = $2.to_i
    property_key = $3
    property_val = $4
    find_network(network_id) do |network|
      find_konekt(network, id: konekt_id) do |konekt|
        begin
          konekt.property_set(property_key, property_val)
        rescue KeyError => ex
          print "[#{network.id_s}][#{konekt.id_s}] ".light_blue
          log_error ex.message
        end
      end
    end
  when 'ls'
  when /\Als konekts\s(\d+)/
    network_id = $1.to_i
    find_network(network_id) do |network|
      puts "=> konekts (main)"
      network.konekt_mains.each do |r|
        puts "[#{network.id_s}] ".light_blue << "#{r.id_s}"
      end
      puts "=> konekts"
      network.konekts.each do |r|
        puts "[#{network.id_s}] ".light_blue << "#{r.id_s}"
      end
    end
  when 'ls networks'
    puts "=> networks"
    @networks.each do |n|
      puts "#{n.id_s}"
    end
  when /save rktm\s(.*)/
    filename = $1
    File.open(filename, "w") { |f| f.write(networks.map(&:to_rktm_h).to_yaml) }
  when 'quit'
    throw :quit
  when 'help'
    puts "too lazy to implement it"
  else
    log_error "unknown command: (#{command})"
  end
end

catch :quit do
  if ARGV.empty?
    loop { prompt; to_commands(gets) { |str| process_command(str) } }
  else
    in_filename = ARGV.first
    to_commands(File.read(in_filename)) do |str|
      prompt; puts "#{str}"
      process_command(str)
    end
  end
end
